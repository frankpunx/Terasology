# ESOF
# RELATÓRIO 3 - *Software Architecture*
## Terasology

#### Introdução

Neste relatório iremos abordar o tema de [Software Architecture](https://msdn.microsoft.com/en-us/library/ee658098.aspx) em engenharia de *software*, a qual consiste na organização 
de um sistema de *software*, incluindo a selecção dos elementos estruturais e as interfaces na qual o sistema é composto.

#### *Software Architecture* do Terasology

A arquitectura de software no Terasology, apesar de não estabelecer uma formalização definida de início, com o desenvolvimento do 
projecto, os colaboradores sentiram necessidade de criar e definir o seu próprio [*Entity System Architecture*](https://github.com/MovingBlocks/Terasology/wiki/Entity-System-Architecture)
para uma melhor orientação e organização dos elementos estruturais.

Alguns dos principais objectivos da arquitetura do *Terasology* estão definidos no seu próprio [*forum*](http://forum.terasology.org/threads/architecture-vision.690/)
onde podemos dar realce a alguns que nos parecem relevantes destacar:

####1) 
Capacidade [*modding*](https://en.wikipedia.org/wiki/Mod_(video_gaming)), com o objectivo de evitar possíveis conflitos;
introduzir novas funcionalidades; introdução de comportamentos novos no jogo; maior capacidade de resistência a potenciais erros
e alterações; segurança em particular para quem faz *downloads* de *plugins* dos servidores dedicados. 
####2)
Separação no que diz respeito à *engine* e da lógica *game/assets*. A *engine* deve-se centrar com as características e funcionalidades 
como *rendering*, som e *voxel world support*. 
A lógica do jogo é alcançada através de *modularity*, o que permite alterar qualquer conjunto de módulos com vista
a poder efectuar alterações ao modo de jogo.

O modelo pelo qual decidimos abordar a arquitectura do *Terasology* será através do [Modelo De Vistas 4 + 1](https://en.wikipedia.org/wiki/4%2B1_architectural_view_model):

* Vista Lógica - Diagrama de Pacotes
* Vista de Implementação - Diagrama de Componentes
* Vista do Processo - Diagrama de Atividades
* Vista de *Deployment* - Diagrama de *Deployment*
* Vista de Casos de Utilização (definido no 2º relatório).

#### Vista Lógica
##### Diagrama de *packages*

O [Diagrama de Pacotes](https://en.wikipedia.org/wiki/Package_diagram) tem como principal função apresentar as principais 
abstrações do sistema existente em Terasology, explicitando os pacotes mais relevantes definidos e as dependências 
existentes no mesmo.

![Diagrama de Pacotes](./Resources/<nome do ficheiro.png)

####Interpretação

No diagrama exposto ilustra-se vários [*Packages*](https://github.com/MovingBlocks/Terasology/wiki/Codebase-Structure) que respeitam a estrutura Terasoly.
Devido à sua dimensão ser um pouco extensa, cabe-nos explitar apenas os que consideramos relevantes para o *core* do 
funcionamento do Terasology.
Assim, como entrada do jogo o temos *Package* *game* que utiliza o *Package* *engine* para se iniciar
o jogo, em que neste caso é o *Package* responsável por todo o desenrolar do jogo. 
O *Package* *facade* neste caso em concreto é utilizado como *wrapper* do *engine* uma vez que é o que permite correr
o jogo como aplicação nos vários Sistemas Operativos dos *users*, já que o *engine* por si só não é executável.
As *Mods* são modificações que o utilizador pode efectuar ao jogo.
Quanto aos *Modules*, estes são contentores de código e *assets* que podem ser usados nos *game types*, tendo também 
acesso a uma parte limitada à *engine* através da *Modding API*.
Em relação a outros *Packages*, não os destacamos aqui de forma particular, mas realçamos o seu valor holístico no 
sistema Terasology.

#### Vista de Implementação
##### Diagrama de componentes
Mostra os componentes de *software* e as dependências entre eles.

![Component Diagram](https://github.com/frankpunx/Terasology/blob/master/ESOF-docs/vista_implementacao.PNG)

O *Entity System* é no Terasology o *core framework* para a lógica de jogo, sendo quase tudo no jogo uma *entity*.
Este sistema foi escolhido pois fornece flexibilidade e suporte para extensão, e permite suporte para *mods* sem necessidade
de escrita de código.

A a maior parte das *Entity System* são definidas como interfaces sendo depois implementadas como um conjunto de classes.

No *core* da *Entity System* temos *entities* ("objetos", que podemos identificar no jogo), uma *entity* por si só não faz nada,
é apenas um contentor lógico para um ou mais *Components* (fornecem *data* e comportamento através da sua interação com *Systems*).

Um *Component* é um conjunto de dados, com a intensão de ser usado para fornecer comportamentos, que pode ser ligado a uma 
*entity*. Tipicamente um *component* é um objecto em Java com um conjunto de valores e funcionalidade minimal. Podem 
existir metodos relacionados a dados, mas não deveram conter nenhuma lógica de jogo, isto deverá ser fornecido por *Systems*.

Uma *entity* só pode ter no máximo um *Component* de um determinado tipo.

*ComponentSystems*, ou *Systems*, fornecem comportamento as *entities*. Isto é feito de duas maneira:
* Processando *entities* com um conjunto de *components* em resposta a uma chamada de um método.
* Resposta a *entity events* mandados a *entities*

Este sistema de *Entities* compostas por *Components* com *Systems* a fornecerem comportamento permitem flexibilidade
e extensibilidade. Frequentemente novos comportamentos podem ser introduzidos através de novos *components* e *systems*.
Um comportamento pode ser mudado removedo um *system* e colocar outro no seu lugar. E *entities* podem ser criadas através 
de *components* existentes, sem escrever código.

*Events* são um mecanismo usado que permite que *systems* interajam entre eles. *Events* são mandados as *entities*.
A vantagem de usar *events* entre *systems* em vez de chamada a métodos, é que, desconecta *systems* e permite adicionar novos *systems* no futuro que reajam 
ao mesmo *event*.

#### Vista do Processo

#### Vista de *Deployment*
##### Diagrama de *Deployment*
Mostra *harware nodes*, relações de comunicação e *software artifacts* implementados neles.

![Deployment Diagram](https://github.com/frankpunx/Terasology/blob/master/ESOF-docs/deployment_diagram.PNG)

Este diagrama mostra as relações de comunicação entre *hardware*, e *software*.
Através do diagrama de *deployment* pode-se entender que o jogo pode ser jogado em modo Single-player como Multi-player. 
O *device* PC que executa e corre o jogo Terasology pode ser realizado através de um *local server* ou *dedicated server*. 
Também é possível jogar o terasology no PC do utilizador através do web browser.
O *local server* pode apenas ser acedido por dispositivos na *local area network - LAN*. Em relação ao servidor principal, neste 
caso apenas é possível executar e jogar através de uma ligação à Internet, logo pode ser acedido por várias redes em áreas geográficas
diferentes. 
No *local server* qualquer novo jogador que pretenda entrar no jogo, assim que inícia a sessão passa a acompanhar de imediato os restantes
jogadores presentes, do mesmo modo que o jogo Minecraft, ao passo que no servidor principal apenas obtém a informação relativa
à sessão corrente.

#### Conclusão
Os diagramas desenvolvidos e estruturados no âmbito do trabalho de *Architectural Design* tiveram em vista compreender 
de forma geral e estruturada os elementos de *software* que incorporam o jogo Terasology, bem como as suas relações e propriedades.

Apresentando os modelos de vistas:
A Vista Lógica é elaborada por um diagrama de pacotes, onde se apresenta as principais abstrações do sistema
o qual mostra as várias unidades lógicas e as dependências entre si existentes no jogo. 

A Vista de Implementação, está expressa por um diagrama de componentes, que representa o modo como os componentes de um sistema de
*software*, neste caso o Terasology, estão relacionados entre si.

Quanto à vista de processo, neste diagrama de atividades, foram apresentados os aspetos dinâmicos do funcionamento do
jogo Terasology.

A vista de deployment, o diagrama de *deployment* pretendeu exibir de que modo são distribuídos os artefactos 
correspondentes aos componentes de *software*, que estão especificados na vista de implementação, 
em componentes - nós - de hardware, permitindo uma melhor noção sobre o modo de funcionamento do jogo. 

Apesar de o jogo Terasology inicialmente não estabelecer formalmente qualquer *Architectural Design*, com o aparecimento 
do colaborador *Immortius* a assumir o papel de *Lead Architect*, permitiu-nos analisar e visualizar com alguma clareza a informação
necessária à construção dos diagramas aqui expostos, possibilitando-nos apresentar uma descrição arquitectural
onde enfatiza os requisitos e vistas arquitecturais, interfaces e componentes, bem como as tecnologias usadas.


##### Referências
[Wikipédia](https://en.wikipedia.org/wiki/4%2B1_architectural_view_model)

[Fórum](http://forum.terasology.org/threads/development-methodology-and-hi-students-from-porto.1387/)
 criado para o fim deste projecto pelo Organizador de Projectos do Terasology

Slides das aulas teóricas

#### Lista dos contribuidores 

#####Grupo 6
* Francisco Veiga
* Paulo Peixoto (0 horas)
* Vasco Pereira (0 horas)
* Filipe Galvão (0 horas)

###### FEUP 2016 MIEIC
